\documentclass[a4paper,12pt]{article}

% Packages
\usepackage{graphicx}  % For images
\usepackage{amsmath}   % For math symbols
\usepackage{hyperref}  % For hyperlinks
\usepackage{fancyhdr}  % For headers
\usepackage{geometry}  % For page layout
\usepackage{xcolor}    % For colors
\usepackage{listings}  % For code snippets
\usepackage{float}     % For image positioning
\usepackage{caption}
\usepackage[utf8]{inputenc} % For special characters
\geometry{a4paper, margin=1in}

% Fancy header/footer settings
\pagestyle{fancy}
\fancyfoot[R]{\thepage} % Right-align page number in the footer
\fancyfoot[C]{}         % Clear the default center-aligned page number

% Title information
\title{Zephyr RTOS Project Report}
\author{
107474-Joseane Pereira \\
109050-Gabriel Costa \\
Universidade de Aveiro, DETI
}
\date{\today}

\begin{document}
\begin{figure}
    \centering
    \includegraphics[width=0.3\linewidth]{ua.pdf}
    \label{fig:enter-label}
\end{figure}
\maketitle
\newpage
\tableofcontents
\newpage

\section{Introduction}
The aim of this project is to apply the Linux Real-Time Services and the Real-Time Model to the development of a real-life inspired real-time application. The project encompasses a set of cooperating tasks, involving synchronization, shared resources, access to a real-time database, etc.

\section{Architecture}
\subsection{System Overview}
In this project, the real-time monitoring system is structured around several primary tasks. These tasks were scheduled using a Static Table-Based Scheduler, which is the most important module of this project. 

Given our use-case, we also implemented a RTDB, in order to have a structure that could store the changes in information.
% In this project, the real-time monitoring system is structured around several primary tasks, each with distinct roles that simulate components in an industrial environment:
% \begin{itemize}
%     \item \textbf{Task 0}: Responsible for updating the RTDB with the button states.
%     \item \textbf{Task 1}: Updates the LED states based on the button states from the RTDB.
%     \item \textbf{Task 2}: Validates RTDB entries and resets them if they are corrupted.
%     \item \textbf{Task 3}: Placeholder for future tasks or additional functionality.
% \end{itemize}

\subsection{Task}
We designed a structure named \textbf{Task} to encapsulate all the necessary information about a task. This includes attributes such as its period (measured in ticks), execution time, and other relevant details.

This information is then used in the STBS to store and manage the information of each task of the system.

\subsection{Static Table-Based Scheduler Implementation}
\subsubsection{Initialization}
To initialize our STBS, we define the time each micro-cycle has, the maximum number of tasks, initialize the number of tasks that the table currently has, and finally, initialize a list of the "Tasks" of the system.

\subsubsection{STBS\_AddTask}
This function is only responsible for initializing a new "Task" and adding it to the Table, making sure it doesn't exceed the maximum number of tasks.

\subsubsection{STBS\_Start}
The function \textbf{STBS\_Start} is invoked after all tasks have been added to the scheduler. Its primary responsibility is to determine whether the tasks are schedulable and, if so, to handle their scheduling and execution. Specifically, this involves assigning each task to its respective micro-cycle. 

Once the scheduling is complete, the function iterates through the micro-cycles, resuming and executing all tasks within each cycle in the predefined order. This process continues until the program is stopped.

\subsubsection{STBS\_print\_content}
This function is responsible for displaying the contents of the table generated by \textbf{STBS\_Start} in a structured, table-like format. This presentation makes it easier to understand how the tasks are organized.

\subsubsection{STBS\_destroy}
This function is responsible for releasing the memory allocated for the STBS and the table it generated.

\subsection{Real-Time Database (RTDB)}
The RTDB is used to store the states of LEDs and buttons, ensuring synchronized access and updates by different tasks.
% \subsection{Data Structures and Access Methods}
% The primary data structure used in this project is the Real-Time Database (RTDB). The RTDB is used to store the states of LEDs and buttons, ensuring synchronized access and updates by different tasks.

% \subsection{Synchronization Mechanisms}
% The implementation relies on multiple threads that perform specific tasks concurrently. To ensure proper coordination, we applied a Static Table Based Scheduler, where the tasks suspend themselves after execution and are resumed by the scheduler.
% \begin{itemize}
%     \item \textbf{Thread Suspension and Resumption}: Tasks suspend themselves after execution and are resumed by the scheduler.
%     \item \textbf{Mutexes}: Used to control access to shared resources and prevent data corruption.
% \end{itemize}
\section{Tasks}
\subsection{Task Characteristics}
The system is composed by the following tasks:
\begin{enumerate}
    \item \textbf{Task 0}: Updates the RTDB with the button states.
    \item \textbf{Task 1}: Updates the LED states based on the button states from the RTDB.
    \item \textbf{Task 2}: Validates RTDB entries and resets them if they are corrupted.
\end{enumerate}

Each task in the system is assigned a specific priority and a period to ensure timely execution and prevent task starvation. The following table outlines the task priorities and activation periods.

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|p{5cm}|}
        \hline
        \textbf{Task} & \textbf{Priority} & \textbf{Activation Period} & \textbf{Description} \\
        \hline
        Task 0 & 1 & 50ms & Updates the RTDB with the button states. \\
        \hline
        Task 1 & 2 & 100ms & Updates the LED states based on the button states from the RTDB. \\
        \hline
        Task 2 & 1 & 100ms & Validates RTDB entries and resets them if they are corrupted. \\
        \hline
    \end{tabular}
    \caption{Task Priorities and Activation Periods}
    \label{tab:task_priorities}
\end{table}

\subsection{Execution Patterns and Relevant Events}
% \textbf{RTDB Operations}: The RTDB is critical for data synchronization:
% TALVEZ POR AQUI UMA PRINT DA TABELA GERADA PELO STBS_START
The RTDB is critical for data synchronization:
\begin{itemize}
    \item \textbf{Task 0} writes to the RTDB, while \textbf{Task 1} and \textbf{Task 2} read from it.
    \item Since there aren't multiple tasks trying to write to the RTDB there is no need to implement mutexes  or other mechanisms to handle concurrent access.
    % \item Mutexes manage concurrent access to prevent data corruption.
\end{itemize}

\section{Real-Time System Characterization}
\subsection{System Performance}
%Placeholder: Analyze the overhead introduced by the scheduler and discuss its efficiency.

%REVIEW THIS
\subsection{System Schedulability}
To confirm that all tasks meet their deadlines, we perform a schedulability analysis using the system's utilization factor.

\textbf{Utilization Factor (U)}: Given that each task is independent and periodic, we can calculate the utilization factor \( U \) using:

\[
U = \sum_{i=1}^n \frac{C_i}{T_i}
\]

where \( C_i \) is the computation time and \( T_i \) is the period of each task. Assuming each task completes within its assigned period, this calculation helps ensure that the system remains schedulable.

% \subsection{Relevant Events and Inter-Task Communication}
% \textbf{RTDB Operations}: The RTDB is critical for data synchronization:
% \begin{itemize}
%     \item \textbf{Task 0} writes to the RTDB, while \textbf{Task 1} and \textbf{Task 2} read from it.
%     \item Since there aren't multiple tasks trying to write to the RTDB there is no need to implement mutexes  or other mechanisms to handle concurrent access.
%     % \item Mutexes manage concurrent access to prevent data corruption.
% \end{itemize}

\section{Use-Case Implementation}
\subsection{Smart I/O Module}
Here, we implemented a mapping from each button to each led, meaning that each button will toggle the state of the respective led.

\subsection{UART Communication Protocol}
In order for the computer to communicate with the Microcontroller, we implemented a simple protocol. It consists in writing commands in the PC, and receiving an ACK message, confirming if the command was executed successfully or if something went wrong (e.g: command doesn't exist or wrong checksum).
In our implementation, every time a command is completed (the user typed the character "\#") the command is processed and executed (if prompted correctly), and the respective acknowledge is sent back as a response.

%POMOS ESTE TEXTO ABAIXO OU N?
We understand that we shouldn't be processing the command inside the UART interrupt function, however, the processing is rather fast and doesn't add much overhead to the execution of the other tasks. % ADD THE PROCESSING TIME HERE

\section{Tests}
The tests for the scheduler verify that tasks are added correctly and meet their deadlines. The test suite includes the following.
\begin{itemize}
    % \item \textbf{Scheduler Initialization Test}: Verifies that the scheduler initializes correctly.
    \item \textbf{Scheduler Test}: Verifies that the scheduler can schedule a schedulable system and detects when the system is not schedulable.
    \item \textbf{Task Addition Test}: Verifies that tasks can be added and appear in the task table.
    \item \textbf{Task Deadline Test}: Verifies that tasks meet their deadlines.
\end{itemize}

\subsection{Scheduler Test}
When testing the scheduler, we noticed that it wasn't detecting when the tasks exceeded their deadline, so we had to make some small changes (which are marked in the code with "CHANGED"), namely, adding this condition
\begin{figure}[H]
    \centering
    \includegraphics[width=0.91\linewidth]{code_change.png}
    % \caption{Code change}
    \label{fig:gantt}
\end{figure}

which checks if a task is delayed past it's deadline.

Now, for the tests, when creating the table, we tested if the tasks that executed in the same micro-cycle with the same priority, are ordered by their period, meaning that the ones with lower period execute first (EDF).
% INSERT AN IMAGE HERE

Then, we tested whether tasks with higher priority execute first.
%Insert an image here

Last but not least, we needed to test if the our code could recognize if a system is not schedulable. For that we did the following tests:
\begin{itemize}
    \item We created a table with a micro-cycle of 50 ms and 4 tasks. These tasks had a period of 1, 3, 2, 2 ticks, priorities of 10, 5, 7, 2 and 20, 25, 30, 15 ms of execution time, respectively. Since the first task has a period of 1 tick and had the lowest priority, it was not able to meet its first deadline, which makes this system not schedulable.

    \item For the next test, we changed the priority of the first task to 1. This system is also not schedulable since the third task is not able to execute before it meets it's deadline, since in the first tick it executes the first and fourth task, and in the second one it executes the first and the second, leaving no time for the third task to execute

    % TALK ABOUT THE TEST OF A SCHEDULABLE SYSTEM
    % \item 

\end{itemize}
\section{Results}
The tests confirm that the scheduler is initialized correctly, tasks are added as expected, and all tasks meet their deadlines within the specified margins.

\section{Conclusion}
In this project, a multi-threaded system was successfully implemented to manage tasks in a real-time environment. The scheduler ensures that tasks are executed periodically and meet their deadlines. The RTDB provides synchronized access to shared data, preventing data corruption. Overall, the project demonstrates effective use of periodic task scheduling, synchronization, and real-time data management.

\end{document}